def fib(n):
    """
        Return the n-th fibonacci number
        Example of the function stack:
        fib(5) ... level 1
            -fib(4) ... level 2
                -fib(3) = 2 ... level 3
                    -fib(2) = 1 ... level 4
                        -fib(1) = 1 ... level 5
                        -fib(0) = 0
                    -fib(1) = 1
                -fib(2)
            -fib(3)
        The stack is created from level 1-5, but
        returned from level 5-1.
    """
    if n == 0 or n == 1:
        return n
    
    return fib(n-1) + fib(n-2)

def sum_fib(n):
    """
        Return the sum from fib(0) to fib(n)
    """
    s = 0
    for i in range(n+1):
        s += fib(i)
    
    return s

def sum_fib2(n):
    """
        Use sum_fib(n) = sum_fib(n-1) + sum_fib(n-2) + fib(1)
    """
    if n == 0 or n == 1:
        return n
    
    return sum_fib2(n-1) + sum_fib2(n-2) + 1


def nested_p(s):
    """
        s is a nested parenthesis when:
        1. s is '()', or
        2. s has a nested parenthesis inside a '()'
        Return whether s is a nested parenthesis.
        e.g.,
        '((((()))))' is a nested parenthesis
        '(((())' is not
        '()()()' is not
        '(()())' is not

        Example of the function stack:
        nested_p('((()))') ... level 1
            - nested_p('(())') ... level 2
                - nested_p('()') ... level 3
    """
    if s == "()":
        return True
    
    if s[0] + s[-1] == '()':
        return nested_p(s[1:-1])
        
    return False

def check_paren(s):
    """
        Example of stack.
        Given a string s containing just the characters 
        '(', ')', '{', '}', '[' and ']', 
        determine if the input string is valid.

        An input string is valid if:
        1. Open brackets must be closed by the same type of brackets.
        2. Open brackets must be closed in the correct order.
        
        Note:
        p = stack.pop() is equal to:
        p = stack[-1]
        stack = stack[:-1]
    """
    stack = []
    for ch in s:
        if ch in {'(', '{', '['}:
            stack.append(ch)
        else:
            p = stack.pop() if len(stack) > 0 else ''
            if p + ch not in {'()','{}','[]'}:
                return False
        
    if len(stack) > 0:
        return False

    return True

def num_decipher(s):
    """
    s is a cipher text containing only '0' and '1',
    and the decipher text may only contain '0', '1', '2', and '3'.
    s is generated by the folloiwng strategy:
    Keep '0', '1', and convert '2'->'10', '3'->'11'
    Return the number of possible decipher text.
    e.g.,
    '10' has 2 possible decipher text: '2', '10'
    '111' has 3 possible decipher text: '111','13','31'
    '01' has 1 possible decipher text
    """
    d = {'':0, '0':1, '1':1, '00':1, '01':1, '10':2, '11':2}

    if len(s) <= 2:
        return d[s]

    if s[-2] == '0':
        return num_decipher(s[:-1])

    return num_decipher(s[:-1]) + num_decipher(s[:-2])


num_decipher_memory = {}

def num_decipher_with_mem(s):
    """
        How to make the recursion faster?
        Use a dictionary to store intermediate results.
    """
    d = {'':0, '0':1, '1':1, '00':1, '01':1, '10':2, '11':2}

    if len(s) <= 2:
        return d[s]
    
    if s not in num_decipher_memory:
        if s[-2] == '0':
            num_decipher_memory[s] = num_decipher_with_mem(s[:-1])
        else:
            num_decipher_memory[s] = (num_decipher_with_mem(s[:-1]) + 
                                    num_decipher_with_mem(s[:-2]))

    return num_decipher_memory[s]


if __name__ == "__main__":
    import time
    s = '10101011101010011'*3
    start = time.time()
    print(num_decipher(s), 'time used (second): ', time.time()-start)
    start = time.time()
    print(num_decipher_with_mem(s), 'time used (second): ', time.time()-start)